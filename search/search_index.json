{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Training Description","text":"<p>Please follow the package, class, and method names as described in the exercises.</p>"},{"location":"#technical-environment","title":"Technical Environment","text":""},{"location":"#java","title":"Java","text":"<ul> <li>openjdk-20 </li> <li>At least higher than version 18.</li> </ul>"},{"location":"#c-sharp","title":"C Sharp","text":"<p>Coming soon.</p>"},{"location":"#the-branch-concept-for-the-labs","title":"The Branch Concept for The Labs","text":""},{"location":"#lab-branches-for-coding-challenges","title":"Lab-Branches for Coding Challenges","text":"<p>A fresh codebase for each lab to implement the exercises.</p> <p>The exercises build on each other. You always have a fresh sample solution in the lab branches.</p> <p>Branch name pattern: lab/{versionNumber}/{labNumber}</p>"},{"location":"#solution-branches-for-comparison-and-consolidation","title":"Solution-Branches for Comparison and Consolidation","text":"<p>A possible solution for each lab.</p> <p>For each exercise there is a sample solution for comparison and consolidation.  Of course, there is not one possible solution. The tests, especially the architecture  tests, help to ensure conformance to the clean architecture pattern.</p> <p>Branch name pattern: solution/{versionNumber}/{labNumber}</p>"},{"location":"#lab-description","title":"Lab Description","text":"<p>See lab description online or  publish it local like described here based on the main branch.</p>"},{"location":"#unit-and-architecture-tests","title":"Unit and Architecture Tests","text":"<p>The demo projects contains architecture tests and unit tests to verify your implementation. For the most tasks it is necessary to uncomment unit tests, after implementing the task.  In some cases it is possible to fix or to add import statements within the unit tests.</p>"},{"location":"mkdocs/","title":"Access Lab Description with MkDocs","text":"<p>The lab description is written with MkDocs.</p> <ul> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs/#install-mkdocs","title":"Install MkDocs","text":"<p>See MkDocs Installation Guide.</p>"},{"location":"mkdocs/#prepare-installation-on-ubuntu","title":"Prepare Installation on Ubuntu","text":""},{"location":"mkdocs/#install-python","title":"Install Python","text":"<pre><code>sudo apt-get install python3\n</code></pre>"},{"location":"mkdocs/#install-pip","title":"Install Pip","text":"<pre><code>sudo apt-get install pip\n</code></pre> <p>Check the installation: <pre><code>pip -V\n</code></pre></p>"},{"location":"mkdocs/#prepare-installation-on-windows","title":"Prepare Installation on Windows","text":""},{"location":"mkdocs/#install-python-and-pip","title":"Install Python and Pip","text":"<p>Use the windows installer available here.</p> <p>Check the installation: <pre><code>pip -V\n</code></pre></p>"},{"location":"mkdocs/#install-mkdocs_1","title":"Install MkDocs","text":"<pre><code>pip install mkdocs\n</code></pre> <pre><code>pip install mkdocs-material\n</code></pre> <pre><code>pip install mkdocs-material-extensions\n</code></pre>"},{"location":"mkdocs/#publish-lab-description-locally-with-mkdocs","title":"Publish Lab Description Locally with MkDocs","text":"<ol> <li>mkdocs build</li> <li>mkddocs serve</li> <li>Open in browser</li> </ol>"},{"location":"docs/help/git/","title":"Git","text":"<p>This section describes some useful git basics how you can \"copy\" it to your own remote repo.</p> <ul> <li>Fork The Repository</li> <li>Custom Repository<ul> <li>Clone</li> <li>Change the Remote</li> </ul> </li> </ul>"},{"location":"docs/help/git/#fork-the-repository","title":"Fork The Repository","text":"<p>If you want to keep track of the original repository, but add your own branches simply  fork it.</p> <ol> <li>Navigate to the repository: https://github.com/MatthiasEschhold/hexacleanws</li> <li>In the top-right corner of the page, click Fork.    </li> <li>Do not select Copy the DEFAULT branch only.    </li> <li>Click Create fork. \ud83c\udf89</li> </ol>"},{"location":"docs/help/git/#custom-repository","title":"Custom Repository","text":"<p>If forking the repository is not an option, you need to change the remote origin to yours after cloning it:</p>"},{"location":"docs/help/git/#clone","title":"Clone","text":"<p>To clone the repository simply run:</p> <pre><code>$ git clone https://github.com/MatthiasEschhold/hexacleanws.git\n</code></pre>"},{"location":"docs/help/git/#change-the-remote","title":"Change the Remote","text":"<p>To change the remote origin to your custom one, rename the old one and set the new one:</p> <pre><code># Rename the current origin\n$ git remote rename origin MatthiasEschhold-origin\n\n# Set the new remote origin\n$ git remote set-url origin &lt;https://git-repo/new-repository.git&gt;\n</code></pre>"},{"location":"docs/lab1/lab1/","title":"Domain Ring und Use Case Ring","text":""},{"location":"docs/lab1/lab1/#domain-model","title":"Domain Model","text":"Coding Task 1 Dom\u00e4nenmodell Vehicle <ol> <li>Implementiere das dargestellte Dom\u00e4nenmodell Vehicle</li> <li>Vehicle ist die Root Entity des Dom\u00e4nenmodell.</li> <li>Implementiere die untergeordneten Dom\u00e4nenobjekte als Value Object</li> <li>Erstelle das Package vehicle.domain.model und lege die Dom\u00e4nenobjekte in diesem Package ab</li> <li>Implementiere die im folgenden aufgef\u00fchrten Validierungsregeln in den betroffenen Dom\u00e4nenobjekte</li> </ol>  ![Vehicle Domain Model](../img/vehicle-domain-model.png)      Domain Object Validation Rule Vehicle Alle Eigenschaften m\u00fcssen vorhanden und f\u00fcr sich valide sein. VIN Ein valider Wert muss dem Vin-Regex-Pattern folgen. LicensePlate Ein valider Wert muss dem LicensePlate-Regex-Pattern folgen. Mileage Der Kilometerstand muss gr\u00f6\u00dfer 0 sein. EquipmentCode Ein valider Wert muss dem EquipmentCode-Regex-Pattern folgen. Alle anderen Dom\u00e4nenobjekte Kein Nullwerte, keine leeren oder blank Strings Vin-Regex-Pattern <pre><code>// examples\n// WP0ZZZ99ZTS392155\n// WBAOLZ99ZTS349156\n\n\"(?=.*\\\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre> LicensePlate-Regex-Pattern <pre><code> \"[A-Z\u00d6\u00dc\u00c40-9]{1,5}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,10}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,4}\"\"[A-Z\u00d6\u00dc\u00c40-9]{1,5}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,10}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,4}\"  \n</code></pre> EquipmentCode-Regex-Pattern <pre><code>// examples\n// WP0ZZZ99ZTS392155\n// WBAOLZ99ZTS349156\n\n\"(?=.*\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre> Tests Coding Task 1 RUN DomainEntityTest     RUN CleanArchitectureFitnessFunction"},{"location":"docs/lab1/lab1/#domain-service-und-use-cases","title":"Domain Service und Use Cases","text":"Coding Task 2 Erstelle die ein- und ausgehenden Use Cases sowie den Use-Case-Connector (Stereotype Service) <ol> <li>Erstelle das Package domain.service als Subpackage von vehicle und erstelle die Klasse VehicleService </li> <li>Erstelle die Packages usecase.in und usecase.out als Subpackages von vehicle</li> <li>Erstelle den eingehenden Use Case VehicleCommand im daf\u00fcr vorgesehenen Package mit der Schnittstelle createVehicle</li> <li>Erstelle die ausgehenden Use Cases VehicleRepository und FetchVehicleMasterData im daf\u00fcr vorgesehenen Package mit den daf\u00fcr vorgesehenen Schnittstellen</li> <li>Implementiere den Anwendungsfall createVehicle im VehicleService</li> </ol> Schnittstelle VehicleCommand <pre><code>Vehicle createVehicle(Vin vin, VehicleMotionData vehicleMotionData);\n</code></pre> Schnittstelle VehicleRepository <pre><code>Vehicle save(Vehicle vehicle);\n</code></pre> Schnittstelle FetchVehicleMasterData <pre><code>VehicleMasterData fetch(Vin vin);\n</code></pre> Tests Coding Task 2 RUN UseCaseConnectorTest     RUN CleanArchitectureFitnessFunction"},{"location":"docs/lab2/lab2/","title":"Adapter Ring - Implementierung des Ports &amp; Adapters Pattern","text":""},{"location":"docs/lab2/lab2/#input-adapter","title":"Input Adapter","text":"Coding Task 3 Erstelle einen Input Adapter f\u00fcr den eingehenden Use Case <ol> <li>Erstelle das Package adapter.in als Subpackage von vehicle und erstelle den Interface Adapter VehicleController</li> <li>Implementiere die technische HTTP Schnittstelle zur Anlage eines Fahrzeugs und nutze hierf\u00fcr den Use Case VehicleCommand</li> <li>Erstelle das DTO VehicleResource (siehe Vorlage) und ein Mapper (VehicleWebMapper) f\u00fcr das DTO</li>. <li>Ignoriere Details des Frameworks und des REST Architekturstils bei der Implementierung</li> </ol> VehicleResource     ```java public class VehicleResource {      private String vin;     private VehicleMotionDataResource vehicleMotionData;     private VehicleMasterDataResource vehicleMasterData;      public VehicleMasterDataResource getVehicleMasterData() {         return vehicleMasterData;     }      public void setVehicleMasterData(VehicleMasterDataResource vehicleMasterData) {         this.vehicleMasterData = vehicleMasterData;     }      public String getVin() {         return vin;     }      public void setVin(String vin) {         this.vin = vin;     }      public VehicleMotionDataResource getVehicleMotionData() {         return vehicleMotionData;     }      public void setVehicleMotionData(VehicleMotionDataResource vehicleMotionData) {         this.vehicleMotionData = vehicleMotionData;     } }     ```"},{"location":"docs/lab2/lab2/#output-adapter","title":"Output Adapter","text":"Coding Task 4 Erstelle die Output Adapter f\u00fcr die ausgehenden Use Cases <ol> <li>Erstelle das Package adapter.out als Subpackage von vehicle</li> und erstelle das Datenbank Repository VehicleDbRepository <li>Implementiere den Use Case VehicleRepository</li> <li>F\u00fchre das DTO VehicleDbEntity (siehe Vorlage) sowie den Mapper VehicleDbMapper ein</li>. <li>Ignoriere Details des Frameworks bei der Implementierung</li> </ol> VehicleDbEntity     ```java public class VehicleDbEntity {      private String vin;     private String licensePlate;      public String getVin() {         return vin;     }      public void setVin(String vin) {         this.vin = vin;     }      public String getLicensePlate() {         return licensePlate;     }      public void setLicensePlate(String licensePlate) {         this.licensePlate = licensePlate;     } }     ```"},{"location":"docs/lab3/lab3/","title":"Mappings between Boundaries","text":"<p>Currently, the Vehicle is the model of the application, and it is not separated from infrastructure. In conclusion the idea of ports and adapters is not consequently followed. The missing element for a fully decoupled domain from infrastructure is a mapping between these boundaries.</p> <p>Mapping</p> <p>Mappings between boundaries describes a transformation of the state of a source entity model to a target entity model. The following code snippets shows an example of different entity model, where for example the baumuster of VehicleDto must be mapped on the property modelName of Vehicle.</p> <pre><code>public class Vehicle {\n\n    public String modelName;\n\n    public String vin;\n\n    public Double mileage;\n\n}\n</code></pre> <pre><code>public class VehicleDto {\n\n    public String vehicleModel;\n\n    public String vehicleId;\n\n    public Double mileage;\n\n}\n</code></pre> <p>Pro Mapping</p> <ul> <li>         If we don't map between layers, we have to use the same model on both layers, which means that the layers will be         tightly coupled.     </li> <li> Mappings enables use to         <ol> <li>reduce the amount of data from external models,</li> <li>implement a model in our domain language, which is easier to understand and to extend</li> </ol> </li> </ul> <p>Contra Mapping</p> <ul> <li>If we do map between layers, we produce a lot of boilerplate code, which is overkill for many use cases.</li> </ul> <p>All arguments are true. We have to consider our architecture goals for this decision. Our goals are to create a isolated domain, and source code that expresses the domain functionality and language. A key element to reach this is mapping. A good balance between boilerplate code and decoupling can be reached by simplifying and automating mappings based on the so-called Two-Way Mapping Strategy.</p>"},{"location":"docs/lab3/lab3/#data-transfer-objects-between-layers","title":"Data Transfer Objects Between Layers","text":"<p>The class-stereotype Data Transfer Object described data objects provided by infrastructure components. In detail Data Transfer Object can be a:</p> <ul> <li>DbEntity</li> <li>Event</li> <li>Resource</li> <li>Response Object</li> <li>and so on</li> </ul>"},{"location":"docs/lab3/lab3/#benefits-of-mappings","title":"Benefits of Mappings","text":"<p>Stable Domain and Fast Adaption</p> <p>Changes to the infrastructure do not affect the domain. For example an external service changes its response model then the changes affect only the mapper of the adapter. This single point of change enables us to adapt fast to infrastructure changes.</p> <p>In addition to that, it is possible to reduce test efforts. There are no tests of the domain needed when nothing changed. The adapter implementation could be tested in isolation on a pure technical level, which is less complex and cost-intensive.</p> <p>Evolutionary Design</p> <p>Change comes fast and unexpected. But for sure it comes! Domain-related change could arise due to</p> <ul> <li>changing behaviour,</li> <li>new requirements,</li> <li>growing business model,</li> <li>changing business model,</li> <li>new consumers,</li> <li>and so on.</li> </ul> <p>Since we cannot foresee change, we must look ahead and act. On an architectural level, this means that we have to apply architecture and design principle that enables change.</p> <p>The idea of ports and adapters is a powerful pattern to support change based on the decoupling of domain and infrastructure. Each of them can grow, modernize and tested independently.</p> Support Mappings with MapStruct <ul> <li>MapStruct Basics</li> <li>Custom Mapper with MapStruct</li> <li>MapStruct Reference Guide Version 1.5.3</li> <li>Other sources</li> </ul>"},{"location":"docs/lab4/lab4/","title":"Ausbau mit weiteren Anforderungen und Funktionalit\u00e4ten","text":"Coding Task 5 Implementiere die Abfrage von Fahrzeudaten anhand der Vin <li>F\u00fchre den eingehenden Use Case VehicleQuery mit der Schnittstelle wie unten beschrieben ein.</li> <li>Erweitere den ausgehenden Use Case VehicleRepository um die Schnittstelle wie unten beschrieben. <li>Implementiere den eingehenden Use Case im VehicleService</li> Schnittstelle VehicleQuery <pre><code>Vehicle findByVin(Vin vin);\n</code></pre> Schnittstelle VehicleRepository <pre><code>VehicleMotionData findVehicleMotionDataByVin(Vin vin);\n</code></pre> Coding Task 5 Erweitere den Anwendungsfall der Fahrzeuganlage <li>F\u00fchre die ausgehenden Use Cases DetectInterpolTheftStatus und FetchHighRiskCountries mit der Schnittstelle wie unten beschrieben ein.</li> <li>Erweitere das Dom\u00e4nenmodell mit den ben\u00f6tigen Dom\u00e4nenobjekten</li> <li>Implementiere die entsprechende ausgehenden Adapter f\u00fcr die eingef\u00fchrten ausgehenden Use Cases</li> <li>F\u00fchre den DomainService TheftRiskRatingService und lege die Klasse im vorgesehenen Package ab</li> <li>Erweitere die Implementierung der Methode createVehicle im VehicleService um die Risikobewertung und die Abfrage bei Interpol</li> <li>Eine Abfrage bei Interpol zum Diebstahlstatus des Fahrzeugs muss ab einem Risikowert von 75 durchgef\u00fchrt werden</li> Schnittstelle DetectInterpolTheftStatus <pre><code>TheftStatus detect(Vin vin, LicensePlate licensePlate);\n</code></pre> <pre><code>public record TheftStatus(TheftStatusEnum value) {\n\n    public TheftStatus {\n        validateTheftStatus(value);\n    }\n\n    private void validateTheftStatus(TheftStatusEnum value) {\n        if (!isTheftStatusValid(value)) {\n            throw new IllegalStateException(\"anti theft status not valid\");\n        }\n    }\n\n    private boolean isTheftStatusValid(TheftStatusEnum value) {\n        return value != null;\n    }\n}\n</code></pre> <pre><code>public enum TheftStatusEnum {\n    UNKNOWN, STOLEN, APPROVED;\n}\n</code></pre> Schnittstelle FetchHighRiskCountries <pre><code>List&lt;HighRiskCountry&gt; fetch();\n</code></pre> <pre><code>public record HighRiskCountry(String value) {\n    private static final String COUNTRY_CODE_PATTERN = \"[A-Z]{2}-[a-z]{2}\";\n    public HighRiskCountry {\n        validateHighRiskCountry(value);\n    }\n\n    private void validateHighRiskCountry(String value) {\n        if (!isHighRiskCountryValid(value)) {\n            throw new IllegalStateException(\"high risk country is not valid\");\n        }\n    }\n\n    private boolean isHighRiskCountryValid(String value) {\n        return value != null &amp;&amp; value.matches(COUNTRY_CODE_PATTERN);\n    }\n}\n</code></pre> Implementierung TheftRiskRatingService <pre><code>public class TheftRiskRatingService {\n\n    private static final String GERMAN_LICENSE_PLATE_PATTERN = \"[A-Z\u00d6\u00dc\u00c4]{1,3}-[A-Z\u00d6\u00dc\u00c4]{1,2} [1-9]{1}[0-9]{1,3}\";\n    private static final String FRANCE_LICENSE_PLATE_PATTERN = \"[A-Z]{3}-[0-9]{3}-[A-Z]{3}\";\n    private static final String GERMAN_COUNTRY_CODE = \"DE-de\";\n    private static final String FRANCE_COUNTRY_CODE = \"FR-fr\";\n\n    public Integer rateTheftRisk(RegistrationCountry registrationCountry, LicensePlate licensePlate, List&lt;HighRiskCountry&gt; highRiskCountries) {\n        Integer riskScore = 0;\n        String countryCodeOfLicensePlate = detectCountryCodeOfLicensePlate(licensePlate);\n        String registrationCountryCode = registrationCountry.value();\n        riskScore = riskScore + detectRiskPointByLicensePlate(countryCodeOfLicensePlate) +\n                detectRiskPointByRegistrationCountry(registrationCountryCode) +\n                detectRiskPointHighRiskCountry(highRiskCountries, countryCodeOfLicensePlate);\n        if (!countryCodeOfLicensePlate.equals(registrationCountry)) {\n            riskScore = riskScore + 15;\n        }\n        return riskScore;\n    }\n\n    private Integer detectRiskPointHighRiskCountry(List&lt;HighRiskCountry&gt; highRiskCountries, String countryCode) {\n        boolean isHighRiskCountry = highRiskCountries.stream().filter(highRiskCountry -&gt; highRiskCountry.equals(countryCode)).findFirst().isPresent();\n        if (isHighRiskCountry) {\n            return 20;\n        }\n        return 0;\n    }\n\n    private Integer detectRiskPointByRegistrationCountry(String countryCode) {\n        if (countryCode.equals(GERMAN_COUNTRY_CODE)) {\n            return 0;\n        } else if (countryCode.equals(FRANCE_COUNTRY_CODE)) {\n            return 0;\n        } else {\n            return 15;\n        }\n    }\n\n    private Integer detectRiskPointByLicensePlate(String countryCode) {\n        if (countryCode.equals(GERMAN_COUNTRY_CODE)) {\n            return 0;\n        } else if (countryCode.equals(FRANCE_COUNTRY_CODE)) {\n            return 5;\n        } else {\n            return 15;\n        }\n    }\n\n    private String detectCountryCodeOfLicensePlate(LicensePlate licensePlate) {\n        if (licensePlate.value().matches(GERMAN_LICENSE_PLATE_PATTERN)) {\n            return \"DE-de\";\n        } else if (licensePlate.value().matches((FRANCE_LICENSE_PLATE_PATTERN))) {\n            return \"FR-fr\";\n        } //... and many more\n        return \"\";\n    }\n\n}\n</code></pre>"},{"location":"docs/lab5/lab5/","title":"Slicing Use Cases with the Interface Segregation Principle","text":"<p>Robert C. Martin points out in his book Clean Architecture that</p>  depending on something that carries baggage that you don't need can cause you trouble that you didn't expect!  <p>The Interface Segregation Principle provides an answer to this problem. It states that broad  interfaces should be split into specific ones so that clients only know the methods they need.</p> <p>Applying the Interface Segregation Principle</p> <ul> <li>removes unnecessary dependencies to methods the consumer doesn't need,</li> <li>makes the existing dependencies more visible,</li> <li>prevents potential trouble based on side effects and,</li> <li>enables extendibility and flexibility </li> </ul> <p>In origin sense the Interface Segregation Principle says:</p> <p>Many client-specific interfaces increase readability and understandability compared to one general-purpose interface.  No clients should be forced to depend on methods it does not use. In conclusion, interfaces should be separated into small  responsibilities as minimalistic as possible.</p> <p></p> <p>Personally I do not use the option Root Entity. As a default I use the option Command &amp; Query. When different consumer exists and there are difference between their needs, then I recommend using the option One Method Per Use Case (Port). Also referring to the package structure variants, there is a separation of incoming and outgoing use cases, which is recommended to apply as standard design principle.</p> <p>Following code examples shows different variants of slicing use cases.</p> <p>Use Cases by Root Entity</p> <pre><code>public interface VehicleUseCase {\n\n    Vehicle readByVin(Vin vin);\n\n    Vehicle readByLicensePlate(LicensePlate licensePlate);\n\n    Vehicle update(Vin vin, VehicleMotionData vehicleMotionData);\n\n    Vehicle create(Vehicle vehicle);\n\n    void delete(Vin vin);\n}\n</code></pre> <p>Use Case by Separating Command and Query</p> <pre><code>public interface VehicleQuery {\n\n    Vehicle readByVin(Vin vin);\n\n    Vehicle readByLicensePlate(LicensePlate licensePlate);\n}\n</code></pre> <pre><code>public interface VehicleCommand {\n\n    Vehicle update(Vin vin, VehicleMotionData vehicleMotionData);\n\n    Vehicle create(Vehicle vehicle);\n\n    void delete(Vin vin);\n}\n</code></pre> <p>A separation in Command and Query helps to prevent, that classes grow into complex and big units of code that are hard to understand. A good orientation for modularisation inside a domain module can be found in Command and Query, even when you do not plan to apply the Command Query Segregation Principle.  But we can create a good foundation for such an evolution.</p> <p>One Method per Use Case (Port)</p> <pre><code>public interface ReadVehicleByVin {\n\n    Vehicle read(Vin vin);\n}\n</code></pre> <pre><code>public interface ReadVehicleByLicensePlate {\n\n    Vehicle read(LicensePlate licensePlate);\n}\n</code></pre> <pre><code>public interface CreateVehicle {\n\n    Vehicle readByVin(Vin vin);\n\n    Vehicle readByLicensePlate(LicensePlate licensePlate);\n}\n</code></pre> <pre><code>public interface UpdateVehicle {\n\n    Vehicle update(Vin vin, VehicleMotionData vehicleMotionData);\n}\n</code></pre> <pre><code>public interface DeleteVehicle {\n\n    void delete(Vin vib);\n}\n</code></pre> <p>Even when the variant One Method per Use Case is not typical Java, slicing use cases this way reduces coupling between clients. In conclusion, the overall coupling between components of the software system will be kept low. Coupling rises quickly and unavoidable. Due to this, we should avoid it every time when possible, especially in fast-growing software systems for complex business domains.</p> <p>Small sliced use cases allow assembling these use cases to a higher composition of functionality. Based on this, functionality can be extended fast for new or changing business processes or user group specific requirements.</p>"},{"location":"docs/lab5/lab5/#slicing-use-cases-in-practice","title":"Slicing Use Cases in Practice","text":"<p>There is no right way by default. It depends on complexity and specific requirements of the project.  In practice a reasonable combination of these variants is may the best way to find a good balance between flexibility and  simplicity in the architecture in the long term.</p> <p>Let's have a look on following functional requirements. As we already know, we have the mission to build a great garage management that is maintainable, extendable and flexible. We want to modernize existing business processes and establish new business models. And the system now starts to live, and we can expect an evolution over the years because the business model change over time due to changing requirements of the stakeholder as well as technical evolution, which creates the need of modernization.</p>"}]}